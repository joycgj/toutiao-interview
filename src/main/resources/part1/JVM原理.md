## JVM原理

JVM本身是介于JAVA编译器和操作系统之间的程序，这个程序提供了一个无视操作系统和硬件平台的运行环境。

### Java内存区域的分配

以1.8为例，内存区域如下：
![](https://github.com/xbox1994/2018-Java-Interview/raw/master/images/j1.jpg)

按线程是否共享分为以下区域：

所有线程共享的数据区：

1. 方法区（JVM规范中的一部分，并不是实际的实现）：存储已被虚拟机加载的类信息、方法信息、常量、静态变量、字节码、JIT编译后的本地代码，并使用永久代来实现方法区。1.8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，元空间中存在JIT即时编译后的native代码，可能还存在短指针数据区CCS
2. 堆区：最大的一块区域，用于存放对象的区域，1.7之后常量池移到这里

每个线程都会有一块私有的数据区：

1. 虚拟机栈：每个方法执行时在其中创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息
2. 本地方法栈：功能与虚拟机栈相同，为native方法服务
3. 程序计数器：存放当前正在执行的指令的地址

直接内存：

* 直接内存并非Java标准
* JDK1.4加入新的NIO机制，目的是防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native的方式直接在Native堆分配内存
* 直接内存区域是全局共享的内存区域

### Java对象不都是分配在堆上
还能分配在栈上
#### 逃逸分析
逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其他变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其他变量引用。正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。

逃逸分析可以分析出某个对象是否永远只在某个方法、线程范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上份分配，由于该对象一定是局部的，所以栈上分配不会有问题。