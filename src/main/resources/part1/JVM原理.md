## JVM原理

JVM本身是介于JAVA编译器和操作系统之间的程序，这个程序提供了一个无视操作系统和硬件平台的运行环境。

### Java内存区域的分配

以1.8为例，内存区域如下：
![](https://github.com/xbox1994/2018-Java-Interview/raw/master/images/j1.jpg)

按线程是否共享分为以下区域：

所有线程共享的数据区：

1. 方法区（JVM规范中的一部分，并不是实际的实现）：存储已被虚拟机加载的类信息、方法信息、常量、静态变量、字节码、JIT编译后的本地代码，并使用永久代来实现方法区。1.8中用元空间替代了永久代，元空间并不在虚拟机中，而是使用本地内存，元空间中存在JIT即时编译后的native代码，可能还存在短指针数据区CCS
2. 堆区：最大的一块区域，用于存放对象的区域，1.7之后常量池移到这里

每个线程都会有一块私有的数据区：

1. 虚拟机栈：每个方法执行时在其中创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息
2. 本地方法栈：功能与虚拟机栈相同，为native方法服务
3. 程序计数器：存放当前正在执行的指令的地址

直接内存：

* 直接内存并非Java标准
* JDK1.4加入新的NIO机制，目的是防止Java堆和Native堆之间往复的数据复制带来的性能损耗，此后NIO可以使用Native的方式直接在Native堆分配内存
* 直接内存区域是全局共享的内存区域

### Java对象不都是分配在堆上
还能分配在栈上
#### 逃逸分析
逃逸是指在某个方法之内创建的对象，除了在方法体之内被引用之外，还在方法体之外被其他变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收，由于其被其他变量引用。正常的方法调用中，方法体中创建的对象将在执行完毕之后，将回收其中创建的对象；故由于无法回收，即成为逃逸。

逃逸分析可以分析出某个对象是否永远只在某个方法、线程范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上份分配，由于该对象一定是局部的，所以栈上分配不会有问题。

### TLAB
JVM在内存新生代Eden Space中开辟了一小块线程私有的区域TLAB（Thread-local allocation buffer）。在Java程序中很多对象都是小对象且用过即丢，它们不存在线程共享也适合被快速GC，所以对于小对象通常JVM会优先分配在TLAB上，并且TLAB上的分配由于是线程私有所以没有锁开销。因此在实践中分配多个小对象的效率通常比分配一个大对象的效率要高。
也就是说，Java中每个线程都会有自己的缓冲区称作TLAB，在对象分配的时候不用锁住整个堆，而只需要在自己的缓冲区分配即可。

### 类加载机制
#### 初始化时机
new、静态字段或方法被使用、反射、父类、main函数调用

#### 加载过程

1. 加载（获取字节流并转换成运行时数据结构，然后生成Class对象）
2. 验证（验证字节流信息符合当前虚拟机的要求）
3. 准备（为类变量分配内存并设置初始值）
4. 解析（将常量池的符号引用替换为直接引用）
5. 初始化（执行类构造器-类变量赋值和静态块的过程）

#### 类加载器
启动类加载器
扩展类加载器
系统类加载器

定义：如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是**双亲委派模式**。

优点：采用双亲委派模式的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次防止恶意覆盖Java核心API。

### 内存分配（堆上的内存分配）
![](https://github.com/xbox1994/2018-Java-Interview/raw/master/images/j2.jpg)
#### 新生代
##### 进入条件
优先选择在新生代的Eden区被分配。
#### 老年代
##### 进入条件
1. 大对象，-XX:PretenureSizeThreshold 大于这个参数的对象直接在老年代分配，来避免新生代GC以及分配担保机制和Eden与Survivor之间的复制
2. 经过第一次Minor GC仍然存在，能被Survivor容纳，就会被移动到Survivor中，此时年龄为1，当年龄大于预设值就进入老年代
3. 如果Survivor中相同年龄所有对象的总和大于Survivor空间的一半，年龄大于等于该年龄的对象进入老年代
4. 如果Survivor空间无法容纳新生代中Minor GC之后还存活的对象

### GC回收机制
#### 回收对象
不可达对象：通过一些列的GC Roots的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时则此对象是不可用的。
GC Roots包括：虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中JNI（Native方法）引用的对象。

彻底死亡条件：
条件1：通过GC Roots作为起点的向下搜索形成引用链，没有搜到该对象，这是第一次标记。
条件2：在finalize方法中没有逃脱回收（将自身被其他对象引用），这是第一次标记的清理。

#### 如何回收
新生代因为每次GC都有大批对象死去，只需要付出少量存活对象的复制成本且无碎片所以使用“复制算法”
老年代因为存活率高、没有分配担保空间，所以使用“标记-清理”或者“标记-整理”算法

复制算法：
标记-清除：
标记-整理：

#### Minor GC条件
当Eden区空间不足以继续分配对象，发起Minor GC。

#### Full GC条件
1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足（通过Minor GC后进入老年代的大小大于老年代的可用内存）
3. 方法区空间不足

## 【Java内存模型]】(https://mp.weixin.qq.com/s/ME_rVwhstQ7FGLPVcfpugQ)
定义：JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。
目的是保证并发编程场景中的原子性、可见性和有序性

实现：volatile、synchronized、final、concurrent包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字

![](https://github.com/xbox1994/2018-Java-Interview/raw/master/images/j12.jpg)

主内存：所有变量都保存在主内存中
工作内存：每个线程的独立内存，保存了该线程使用到的变量的主内存副本拷贝，线程对变量的操作必须在工作内存中进行

每个线程都有自己的本地内存共享副本，如果A线程要更新主内存还要让B线程获取更新后的变量，那么需要：

1. 将本地内存A中更新共享变量
2. 将更新的共享变量刷新到主内存
3. 线程B从主内存更新最新的共享变量

## [happens-before](https://www.cnblogs.com/chenssy/p/6393321.html)
我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before。特别关注在多线程之间的内存可见性。

它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下量操作之间是否可能存在冲突的所有问题。

1. 程序次序规则
2. 锁定规则
3. volatile变量规则
4. 传递规则
5. 线程启动规则
6. 线程中断规则
7. 线程终结规则
8. 对象终结规则

## 垃圾收集器
### 串行收集器
### 并行收集器
### 并发收集器

### 如何选择垃圾收集器
1. 需要停顿时间能超过1秒且想要一个可控的吞吐量时，使用并行收集器
2. 如果停顿时间重要且不超过1秒，使用并发收集器
3. 如果内存小于100M，使用串行或者JVM自己选
4. 如果是单核，且没有系统停顿要求，使用串行或者JVM自己选

## Stop The World
简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互

STW总会发生，不管是新生代还是老年代，比如CMS在初始标记和重复标记阶段会停顿，G1在初始标记阶段也会停顿，所以并不是选择了一款停顿时间低的垃圾收集器就可以避免STW的，我们只能尽量去减少STW的时间。

























